<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QR Code 生成器</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: "Microsoft YaHei", "Arial", sans-serif; background: #f5f5f5; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; background: #fff; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .alert { padding: 15px; border-radius: 6px; margin-bottom: 20px; text-align: center; font-weight: 600; display: none; }
        .alert-error { background: #fef2f2; color: #dc2626; border: 1px solid #fecdd3; }
        .alert-loading { background: #eff6ff; color: #2563eb; border: 1px solid #bfdbfe; }
        h1 { text-align: center; color: #dc2626; margin-bottom: 10px; font-size: 24px; }
        .subtitle { text-align: center; color: #64748b; margin-bottom: 30px; font-size: 16px; }
        .tabs { display: flex; justify-content: center; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        .tab-btn { padding: 10px 25px; border: none; border-radius: 6px; background: #e2e8f0; cursor: pointer; font-size: 16px; transition: background 0.2s; }
        .tab-btn.active { background: #dc2626; color: #fff; }
        .tab-btn:hover:not(.active) { background: #cbd5e1; }
        .actions { text-align: center; margin-bottom: 20px; }
        .action-btn { padding: 10px 20px; border: none; border-radius: 6px; color: #fff; cursor: pointer; font-size: 14px; margin: 0 5px; transition: background 0.2s; }
        .btn-print { background: #16a34a; }
        .btn-refresh { background: #f59e0b; }
        .btn-test { background: #6366f1; }
        .btn-print:hover { background: #15803d; }
        .btn-refresh:hover { background: #d97706; }
        .btn-test:hover { background: #4f46e5; }
        .qr-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 20px; }
        .qr-card { 
            text-align: center; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); 
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        /* 二维码容器：居中+固定尺寸 */
        .qr-container {
            width: var(--qr-size);
            height: var(--qr-size);
            margin: 0 auto 15px;
            position: relative;
            border: 1px solid #eee;
            background: #fff;
        }
        .qr-img {
            width: 100%;
            height: 100%;
        }
        /* 二维码下方文字：居中+可配置样式 */
        .qr-label {
            font-weight: 600;
            margin-bottom: 10px;
            font-size: var(--qr-text-size);
            color: var(--qr-text-color);
            text-align: center;
            width: 100%;
            word-break: break-all;
            padding: 0 10px;
        }
        .download-btn { 
            padding: 8px 20px; 
            background: #2563eb; 
            color: #fff; 
            border: none; 
            border-radius: 4px; 
            cursor: pointer; 
            transition: background 0.2s;
            margin-top: 5px;
        }
        .download-btn:hover { background: #1d4ed8; }
        .status { text-align: center; padding: 50px 0; color: #64748b; font-size: 18px; }
        /* 打印优化 */
        @media print { 
            .alert, .tabs, .actions, .download-btn { display: none; } 
            .qr-grid { grid-template-columns: repeat(3, 1fr); gap: 15px; } 
            .qr-card { box-shadow: none; border: 1px solid #eee; page-break-inside: avoid; }
            .qr-container { width: 150px; height: 150px; }
        }
        /* 移动端适配 */
        @media (max-width: 768px) {
            .qr-grid { grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); }
            .qr-container { width: 150px !important; height: 150px !important; }
            .action-btn { padding: 8px 15px; margin: 0 3px 8px; }
            .tab-btn { padding: 8px 20px; }
            .container { padding: 20px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 错误提示框 -->
        <div id="errorAlert" class="alert alert-error"></div>
        <!-- 加载提示框 -->
        <div id="loadingAlert" class="alert alert-loading">加载中，请稍候...</div>

        <h1>QR Code 生成器</h1>
        <p class="subtitle">用户/游戏二维码生成（支持下载/打印）</p>

        <div class="tabs">
            <button class="tab-btn active" id="tabUser">用户 QR Code</button>
            <button class="tab-btn" id="tabGame">游戏 QR Code</button>
        </div>

        <div class="actions">
            <button class="action-btn btn-print" id="btnPrint">列印所有</button>
            <button class="action-btn btn-refresh" id="btnRefresh">刷新數據</button>
            <button class="action-btn btn-test" id="btnTest">測試連接</button>
        </div>

        <!-- 用户二维码区域 -->
        <div id="userGrid" class="qr-grid status">加载用户数据中...</div>
        <!-- 游戏二维码区域（默认隐藏） -->
        <div id="gameGrid" class="qr-grid status" style="display: none;">加载游戏数据中...</div>
    </div>

    <!-- 加载Supabase库（和登录页一致） -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.3/dist/umd/supabase.min.js"></script>
    
    <!-- 加载配置文件 -->
    <script src="js/qrcode.js"></script>

    <script>
        // 增强版原生QRCode生成器（修复生成逻辑+支持自定义尺寸）
        class NativeQRCode {
            constructor(text, options = {}) {
                this.text = text || '';
                // 合并默认配置和自定义配置
                this.options = {
                    size: 180,
                    cellSize: 8,
                    margin: 10,
                    color: '#000000',
                    bgColor: '#ffffff',
                    ...options
                };
                // QRCode版本适配（根据文本长度自动选择）
                this.version = this.getVersionByTextLength(text);
                this.errorCorrection = 'H'; // 高容错级别
            }

            // 根据文本长度选择QRCode版本（修复生成失败核心）
            getVersionByTextLength(text) {
                const length = text.length;
                if (length <= 25) return 1;   // 短文本（用户名/游戏码）
                if (length <= 47) return 2;   // 中等文本
                return 3;                     // 较长文本
            }

            // 生成二维码矩阵（修复核心：适配不同版本）
            generateMatrix() {
                const version = this.version;
                const matrixSize = 21 + (version - 1) * 4; // 版本对应矩阵大小
                const matrix = Array(matrixSize).fill(0).map(() => Array(matrixSize).fill(0));

                // 绘制定位图案（三个角）
                this.drawPositionPattern(matrix, 0, 0);
                this.drawPositionPattern(matrix, matrixSize - 7, 0);
                this.drawPositionPattern(matrix, 0, matrixSize - 7);

                // 绘制时序图案
                this.drawTimingPattern(matrix, matrixSize);

                // 绘制对齐图案（适配高版本）
                if (version >= 2) {
                    this.drawAlignmentPattern(matrix, version);
                }

                // 数据编码（修复：完整的ASCII编码）
                const dataBits = this.encodeTextToBits(this.text);
                this.fillDataBits(matrix, dataBits, matrixSize);

                return matrix;
            }

            // 绘制定位图案（修复：精准的黑白格）
            drawPositionPattern(matrix, x, y) {
                for (let i = -3; i <= 3; i++) {
                    for (let j = -3; j <= 3; j++) {
                        const px = x + i;
                        const py = y + j;
                        if (px < 0 || py < 0 || px >= matrix.length || py >= matrix.length) continue;
                        // 定位图案标准格式：外黑内白，中心黑
                        if (Math.abs(i) === 3 || Math.abs(j) === 3) {
                            matrix[py][px] = 1;
                        } else if (Math.abs(i) === 2 || Math.abs(j) === 2) {
                            matrix[py][px] = 0;
                        } else if (Math.abs(i) < 2 && Math.abs(j) < 2) {
                            matrix[py][px] = 1;
                        }
                    }
                }
            }

            // 绘制时序图案
            drawTimingPattern(matrix, size) {
                for (let x = 8; x < size - 8; x++) {
                    if (matrix[6][x] === undefined) matrix[6][x] = x % 2;
                }
                for (let y = 8; y < size - 8; y++) {
                    if (matrix[y][6] === undefined) matrix[y][6] = y % 2;
                }
            }

            // 绘制对齐图案（适配高版本）
            drawAlignmentPattern(matrix, version) {
                const alignmentPositions = [
                    [], [6], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34],
                    [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54],
                    [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70]
                ];
                const positions = alignmentPositions[version] || [];
                positions.forEach(x => {
                    positions.forEach(y => {
                        if ((x < 7 && y < 7) || (x > matrix.length - 8 && y < 7) || (x < 7 && y > matrix.length - 8)) return;
                        for (let i = -2; i <= 2; i++) {
                            for (let j = -2; j <= 2; j++) {
                                const px = x + i;
                                const py = y + j;
                                if (px < 0 || py < 0 || px >= matrix.length || py >= matrix.length) continue;
                                if (Math.abs(i) === 2 || Math.abs(j) === 2) {
                                    matrix[py][px] = 1;
                                } else if (i === 0 && j === 0) {
                                    matrix[py][px] = 1;
                                } else {
                                    matrix[py][px] = 0;
                                }
                            }
                        }
                    });
                });
            }

            // 文本转二进制位（完整ASCII编码，修复生成失败）
            encodeTextToBits(text) {
                let bits = [];
                // 模式指示符：8位字节模式
                bits = bits.concat([0, 1, 0, 0]);
                // 字符长度
                const lengthBits = this.numberToBits(text.length, this.getLengthBitsCount());
                bits = bits.concat(lengthBits);
                // 字符编码
                for (let i = 0; i < text.length; i++) {
                    const charCode = text.charCodeAt(i);
                    bits = bits.concat(this.numberToBits(charCode, 8));
                }
                // 添加结束位
                bits = bits.concat([0, 0, 0, 0]);
                // 填充到8的倍数
                while (bits.length % 8 !== 0) {
                    bits.push(0);
                }
                // 填充数据（QRCode标准）
                const fillPattern = [1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1];
                let fillIndex = 0;
                const maxBits = this.getMaxBitsCount();
                while (bits.length < maxBits) {
                    bits.push(fillPattern[fillIndex % fillPattern.length]);
                    fillIndex++;
                }
                return bits.slice(0, maxBits);
            }

            // 数字转指定位数的二进制数组
            numberToBits(num, bitsCount) {
                const bits = [];
                for (let i = bitsCount - 1; i >= 0; i--) {
                    bits.push((num >> i) & 1);
                }
                return bits;
            }

            // 获取长度位数量（根据版本和模式）
            getLengthBitsCount() {
                return this.version <= 9 ? 8 : 16;
            }

            // 获取最大数据位数量（根据版本和容错级别）
            getMaxBitsCount() {
                const maxBits = [
                    26, 44, 70, 100, 134, 172, 196, 242, 292, 346,
                    404, 466, 532, 581, 655, 733, 815, 901, 991, 1085
                ];
                const errorCorrectionMultiplier = { 'L': 1, 'M': 0.8, 'Q': 0.6, 'H': 0.5 };
                return Math.floor(maxBits[this.version - 1] * errorCorrectionMultiplier[this.errorCorrection]);
            }

            // 填充数据位到矩阵（修复：正确的填充顺序）
            fillDataBits(matrix, bits, size) {
                let bitIndex = 0;
                let direction = -1;
                // 从右下角开始填充，蛇形填充
                for (let col = size - 1; col >= 0; col -= 2) {
                    if (col === 6) col--; // 跳过时序图案列
                    for (let row = 0; row < size; row += direction) {
                        for (let c of [col, col - 1]) {
                            if (c < 0 || this.isReserved(matrix, c, row)) continue;
                            if (bitIndex >= bits.length) return;
                            matrix[row][c] = bits[bitIndex];
                            bitIndex++;
                        }
                    }
                    direction *= -1;
                }
            }

            // 检查是否是保留区域
            isReserved(matrix, x, y) {
                const size = matrix.length;
                // 定位图案区域
                if ((x < 7 && y < 7) || (x > size - 8 && y < 7) || (x < 7 && y > size - 8)) return true;
                // 时序图案区域
                if (x === 6 || y === 6) return true;
                // 对齐图案区域
                for (let i = -2; i <= 2; i++) {
                    for (let j = -2; j <= 2; j++) {
                        if (matrix[y + j] && matrix[y + j][x + i] === 1 && Math.abs(i) === 2 || Math.abs(j) === 2) {
                            return true;
                        }
                    }
                }
                return false;
            }

            // 渲染到Canvas（支持自定义尺寸）
            renderToCanvas(canvas) {
                const matrix = this.generateMatrix();
                const size = this.options.size;
                const margin = this.options.margin;
                const cellSize = (size - 2 * margin) / matrix.length;

                // 设置Canvas尺寸
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');

                // 清空背景
                ctx.fillStyle = this.options.bgColor;
                ctx.fillRect(0, 0, size, size);

                // 绘制二维码矩阵
                ctx.fillStyle = this.options.color;
                for (let y = 0; y < matrix.length; y++) {
                    for (let x = 0; x < matrix.length; x++) {
                        if (matrix[y][x] === 1) {
                            ctx.fillRect(
                                margin + x * cellSize,
                                margin + y * cellSize,
                                cellSize,
                                cellSize
                            );
                        }
                    }
                }
                return canvas;
            }

            // 创建Canvas并返回
            createCanvas() {
                const canvas = document.createElement('canvas');
                this.renderToCanvas(canvas);
                return canvas;
            }
        }

        // ********** 业务逻辑 **********
        const el = {
            errorAlert: document.getElementById('errorAlert'),
            loadingAlert: document.getElementById('loadingAlert'),
            tabUser: document.getElementById('tabUser'),
            tabGame: document.getElementById('tabGame'),
            btnPrint: document.getElementById('btnPrint'),
            btnRefresh: document.getElementById('btnRefresh'),
            btnTest: document.getElementById('btnTest'),
            userGrid: document.getElementById('userGrid'),
            gameGrid: document.getElementById('gameGrid')
        };

        let supabaseClient = null;
        let activeTab = 'user';

        // 工具函数
        function showAlert(dom, text) { dom.innerText = text; dom.style.display = 'block'; }
        function hideAlert(dom) { dom.style.display = 'none'; }
        function showError(text) { showAlert(el.errorAlert, text); hideAlert(el.loadingAlert); }
        function showLoading() { showAlert(el.loadingAlert, '加载中，请稍候...'); hideAlert(el.errorAlert); }
        function clearAllAlert() { hideAlert(el.errorAlert); hideAlert(el.loadingAlert); }

        // 前置校验
        function preCheck() {
            if (typeof supabase === 'undefined') {
                showError('❌ 数据库连接库加载失败');
                return false;
            }
            if (!window.qrConfig || !window.qrConfig.supabaseUrl || !window.qrConfig.supabaseKey) {
                showError('❌ 配置文件错误或凭证为空');
                return false;
            }
            if (window.qrConfig.supabaseUrl.includes("你的项目ID") || window.qrConfig.supabaseKey.includes("你的anon public key")) {
                showError('❌ 请替换为真实的Supabase凭证');
                return false;
            }
            return true;
        }

        // 初始化Supabase
        function initSupabase() {
            try {
                supabaseClient = supabase.createClient(
                    window.qrConfig.supabaseUrl,
                    window.qrConfig.supabaseKey,
                    {
                        global: {
                            fetch: (url, opts = {}) => {
                                opts.signal = AbortSignal.timeout(window.qrConfig.timeout);
                                return fetch(url, opts);
                            }
                        }
                    }
                );
                return true;
            } catch (err) {
                showError(`❌ 数据库初始化失败：${err.message.slice(0, 50)}`);
                return false;
            }
        }

        // 生成二维码卡片（优化：文字居中显示在二维码下方）
        function createQrCard(qrId, labelText, qrContent, downloadName) {
            const card = document.createElement('div');
            card.className = 'qr-card';

            // 设置CSS变量（用于控制尺寸）
            card.style.setProperty('--qr-size', `${window.qrConfig.qr.size}px`);
            card.style.setProperty('--qr-text-size', `${window.qrConfig.qr.textSize}px`);
            card.style.setProperty('--qr-text-color', window.qrConfig.qr.textColor);

            // 二维码容器（固定尺寸）
            const qrContainer = document.createElement('div');
            qrContainer.className = 'qr-container';
            
            // 二维码Canvas
            const qrCanvas = document.createElement('canvas');
            qrCanvas.id = qrId;
            qrCanvas.className = 'qr-img';
            
            // 生成二维码（使用修复后的生成器）
            const qrGenerator = new NativeQRCode(qrContent, {
                size: window.qrConfig.qr.size,
                cellSize: window.qrConfig.qr.cellSize,
                margin: window.qrConfig.qr.margin,
                color: window.qrConfig.qr.color,
                bgColor: window.qrConfig.qr.bgColor
            });
            qrGenerator.renderToCanvas(qrCanvas);

            // 二维码下方文字（居中显示）
            const label = document.createElement('div');
            label.className = 'qr-label';
            label.innerText = labelText; // 文字显示在二维码正下方

            // 下载按钮
            const downBtn = document.createElement('button');
            downBtn.className = 'download-btn';
            downBtn.innerText = '下载QR Code';
            downBtn.onclick = () => {
                try {
                    const a = document.createElement('a');
                    a.download = `${downloadName}-QRCode.png`;
                    a.href = qrCanvas.toDataURL('image/png', 1.0);
                    a.click();
                } catch (err) {
                    alert('❌ 下载失败，请检查浏览器设置');
                }
            };

            // 组装卡片：二维码容器 → 文字 → 下载按钮
            qrContainer.appendChild(qrCanvas);
            card.appendChild(qrContainer);
            card.appendChild(label);
            card.appendChild(downBtn);
            
            return card;
        }

        // 加载用户数据
        async function loadUserList() {
            if (!supabaseClient) return;
            showLoading();
            el.userGrid.innerHTML = '加载用户数据中...';
            try {
                const { data, error } = await supabaseClient
                    .from('users')
                    .select('id, username')
                    .order('username');
                if (error) throw error;

                if (!data || data.length === 0) {
                    el.userGrid.innerHTML = '❌ 暂无用户数据，请先在数据库添加';
                    hideAlert(el.loadingAlert);
                    return;
                }

                el.userGrid.innerHTML = '';
                data.forEach(user => {
                    el.userGrid.appendChild(createQrCard(
                        `qr-user-${user.id}`,
                        user.username, // 用户名显示在二维码下方
                        user.username,
                        `user-${user.username}`
                    ));
                });
            } catch (err) {
                el.userGrid.innerHTML = `❌ 加载用户失败：${getFriendlyErrMsg(err)}`;
            } finally {
                hideAlert(el.loadingAlert);
            }
        }

        // 加载游戏数据
        async function loadGameList() {
            if (!supabaseClient) return;
            showLoading();
            el.gameGrid.innerHTML = '加载游戏数据中...';
            try {
                const { data, error } = await supabaseClient
                    .from('games')
                    .select('id, game_code, game_name')
                    .order('game_code');
                if (error) throw error;

                if (!data || data.length === 0) {
                    el.gameGrid.innerHTML = '❌ 暂无游戏数据，请先在数据库添加';
                    hideAlert(el.loadingAlert);
                    return;
                }

                el.gameGrid.innerHTML = '';
                data.forEach(game => {
                    const displayText = `${game.game_code}\n(${game.game_name})`; // 换行显示游戏码和名称
                    el.gameGrid.appendChild(createQrCard(
                        `qr-game-${game.id}`,
                        displayText, // 游戏信息显示在二维码下方
                        game.game_code,
                        `game-${game.game_code}`
                    ));
                });
            } catch (err) {
                el.gameGrid.innerHTML = `❌ 加载游戏失败：${getFriendlyErrMsg(err)}`;
            } finally {
                hideAlert(el.loadingAlert);
            }
        }

        // 测试数据库连接
        async function testDatabaseConn() {
            if (!supabaseClient) return;
            showLoading();
            el.userGrid.innerHTML = '测试数据库连接中...';
            try {
                const { data, error } = await supabaseClient
                    .from('users')
                    .select('*')
                    .limit(1);
                if (error) throw error;
                el.userGrid.innerHTML = `✅ 数据库连接成功！用户表当前有${data.length}条数据`;
            } catch (err) {
                el.userGrid.innerHTML = `❌ 数据库连接失败：${getFriendlyErrMsg(err)}`;
            } finally {
                hideAlert(el.loadingAlert);
            }
        }

        // 友好的错误提示
        function getFriendlyErrMsg(err) {
            if (!err || !err.message) return '未知错误';
            const msg = err.message;
            if (msg.includes('401')) return 'Supabase Key错误';
            if (msg.includes('404')) return 'Supabase URL错误';
            if (msg.includes('CORS')) return '跨域配置错误';
            if (msg.includes('timeout')) return '请求超时';
            if (msg.includes('Failed to fetch')) return '网络连接失败';
            if (msg.includes('relation "users" does not exist')) return '数据库无users表';
            return msg.slice(0, 50);
        }

        // 标签切换
        function switchTab(tabType) {
            if (tabType === activeTab) return;
            activeTab = tabType;
            el.tabUser.classList.toggle('active', tabType === 'user');
            el.tabGame.classList.toggle('active', tabType === 'game');
            el.userGrid.style.display = tabType === 'user' ? 'grid' : 'none';
            el.gameGrid.style.display = tabType === 'game' ? 'grid' : 'none';
            if (tabType === 'game' && el.gameGrid.innerHTML.includes('加载游戏数据中')) {
                loadGameList();
            }
        }

        // 绑定事件
        function bindAllEvents() {
            el.tabUser.onclick = () => switchTab('user');
            el.tabGame.onclick = () => switchTab('game');
            el.btnPrint.onclick = () => window.print();
            el.btnRefresh.onclick = () => {
                activeTab === 'user' ? loadUserList() : loadGameList();
            };
            el.btnTest.onclick = testDatabaseConn;
        }

        // 页面初始化
        async function initPage() {
            if (!preCheck()) return;
            if (!initSupabase()) return;
            bindAllEvents();
            await loadUserList();
            clearAllAlert();
        }

        // DOM加载完成后初始化
        document.addEventListener('DOMContentLoaded', initPage);
    </script>
</body>
</html>
